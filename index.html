<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flappy Bird</title>
  <style>
    :root{ --bg1:#70c5ce; --bg2:#b6e8ef; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif;
      background:radial-gradient(1200px 700px at 50% 20%, var(--bg2), var(--bg1));
      display:grid; place-items:center;
      overscroll-behavior:none;
      touch-action:manipulation;
      user-select:none;
    }
    .wrap{width:min(92vw,560px); display:grid; gap:10px; justify-items:center;}
    .topbar{
      width:100%; display:flex; justify-content:space-between; align-items:center; gap:10px;
      padding:8px 10px; border-radius:12px;
      background:rgba(255,255,255,.55);
      backdrop-filter:blur(8px);
      border:1px solid rgba(255,255,255,.35);
    }
    .title{display:flex; flex-direction:column; line-height:1.1}
    .title b{font-size:14px}
    .title span{font-size:12px; color:rgba(0,0,0,.6)}
    .btns{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    button{
      appearance:none; border:0;
      padding:8px 10px; border-radius:10px;
      background:rgba(0,0,0,.75); color:#fff;
      font-weight:650; cursor:pointer;
    }
    button:active{transform:translateY(1px)}
    .stage{
      width:100%; border-radius:18px; overflow:hidden;
      border:1px solid rgba(0,0,0,.15);
      background:linear-gradient(#73d0db,#d4f2f6);
      box-shadow:0 20px 60px rgba(0,0,0,.18);
      position:relative;
    }
    canvas{display:block; width:100%; height:auto;}
    .hint{width:100%; text-align:center; font-size:12px; color:rgba(0,0,0,.65)}
    @media (max-width:360px){ .title span{display:none} button{padding:7px 9px} }

    /* ===== Screamer overlay ===== */
    .screamer{
      position:absolute; inset:0;
      display:none;
      place-items:center;
      background:#000;
      z-index:5;
      pointer-events:none; /* чтобы не мешал кликам */
    }
    .screamer.on{ display:grid; }
    .screamer::before{
      content:"";
      position:absolute; inset:-20%;
      background:
        radial-gradient(circle at 50% 45%, rgba(255,255,255,.12), rgba(0,0,0,.95) 58%),
        repeating-linear-gradient(0deg, rgba(255,255,255,.08), rgba(255,255,255,.08) 2px, rgba(0,0,0,0) 2px, rgba(0,0,0,0) 6px);
      mix-blend-mode:screen;
      opacity:.9;
      transform:scale(1.05);
      filter:contrast(160%) brightness(120%);
    }
    .screamer__inner{
      position:relative;
      width:100%;
      height:100%;
      display:grid;
      place-items:center;
      transform:scale(1);
    }
    .screamer__face{
      width:min(92%, 340px);
      filter: drop-shadow(0 24px 60px rgba(255,0,0,.22)) drop-shadow(0 0 18px rgba(255,255,255,.06));
    }
    .screamer__text{
      position:absolute;
      bottom:18px;
      left:0; right:0;
      text-align:center;
      font-weight:900;
      letter-spacing:.12em;
      font-size:14px;
      color:rgba(255,255,255,.75);
      text-transform:uppercase;
      text-shadow:0 2px 18px rgba(255,0,0,.28);
    }

    /* Анимации: вспышка/дрожание/зум */
    .screamer.on{ animation: scrFlash 420ms steps(1,end) 1; }
    .screamer.on .screamer__inner{ animation: scrShake 480ms linear 1, scrZoom 380ms ease-out 1; }
    .screamer.on .screamer__face{ animation: scrJitter 480ms linear 1; }

    @keyframes scrFlash{
      0%{ background:#fff; }
      10%{ background:#000; }
      20%{ background:#fff; }
      35%{ background:#000; }
      100%{ background:#000; }
    }
    @keyframes scrShake{
      0%{ transform:translate(0,0) }
      10%{ transform:translate(-6px, 4px) }
      20%{ transform:translate(7px, -5px) }
      30%{ transform:translate(-8px, -3px) }
      40%{ transform:translate(6px, 6px) }
      55%{ transform:translate(-5px, 3px) }
      70%{ transform:translate(4px, -4px) }
      100%{ transform:translate(0,0) }
    }
    @keyframes scrZoom{
      0%{ transform:scale(1.0) }
      100%{ transform:scale(1.12) }
    }
    @keyframes scrJitter{
      0%, 100%{ filter:contrast(115%) brightness(110%); }
      25%{ filter:contrast(160%) brightness(135%); }
      50%{ filter:contrast(130%) brightness(120%); }
      75%{ filter:contrast(180%) brightness(140%); }
    }

    /* Если у пользователя reduced motion — уменьшаем «ударность» */
    @media (prefers-reduced-motion: reduce){
      .screamer.on, .screamer.on .screamer__inner, .screamer.on .screamer__face{ animation:none !important; }
      .screamer::before{ opacity:.55; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <b>Flappy Bird — авто + уровни + скример</b>
        <span> P — пауза, R — рестарт (Space/↑/клик — взмах)</span>
      </div>
      <div class="btns">
        <button id="btnAuto" type="button">Авто: ВКЛ</button>
        <button id="btnScreamer" type="button">Скример: ВКЛ</button>
        <button id="btnPause" type="button">Пауза</button>
        <button id="btnReset" type="button">Рестарт</button>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="c" width="288" height="512" aria-label="Flappy Bird canvas"></canvas>

      <!-- Screamer overlay -->
      <div class="screamer" id="screamer" aria-hidden="true">
        <div class="screamer__inner">
          <!-- Inline SVG face (без внешних картинок) -->
          <svg class="screamer__face" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="screamer">
            <defs>
              <radialGradient id="bg" cx="50%" cy="45%" r="70%">
                <stop offset="0%" stop-color="#1a0000"/>
                <stop offset="55%" stop-color="#000"/>
                <stop offset="100%" stop-color="#000"/>
              </radialGradient>
              <filter id="noise">
                <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch" />
                <feColorMatrix type="matrix" values="
                  1 0 0 0 0
                  0 0 0 0 0
                  0 0 0 0 0
                  0 0 0 .18 0" />
              </filter>
              <filter id="glow">
                <feGaussianBlur stdDeviation="2.6" result="b"/>
                <feMerge>
                  <feMergeNode in="b"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>

            <rect width="300" height="300" fill="url(#bg)"/>
            <rect width="300" height="300" filter="url(#noise)" opacity="0.65"/>

            <!-- head silhouette -->
            <path d="M150 36c52 0 88 38 88 92v38c0 70-46 118-88 118s-88-48-88-118v-38c0-54 36-92 88-92z"
                  fill="#0a0a0a" stroke="rgba(255,255,255,.06)" stroke-width="2"/>

            <!-- eyes -->
            <g filter="url(#glow)">
              <path d="M70 134c20-22 48-22 68 0-8 22-20 34-34 34s-26-12-34-34z"
                    fill="#f2f2f2"/>
              <path d="M162 134c20-22 48-22 68 0-8 22-20 34-34 34s-26-12-34-34z"
                    fill="#f2f2f2"/>
              <circle cx="105" cy="146" r="8" fill="#000"/>
              <circle cx="196" cy="146" r="8" fill="#000"/>
              <circle cx="102" cy="143" r="2" fill="#fff" opacity="0.8"/>
              <circle cx="193" cy="143" r="2" fill="#fff" opacity="0.8"/>
            </g>

            <!-- mouth -->
            <path d="M105 210c20 35 70 35 90 0 12-20 9-44-45-44s-57 24-45 44z"
                  fill="#050505" stroke="rgba(255,255,255,.08)" stroke-width="2"/>
            <path d="M120 206c18 24 42 24 60 0" fill="none" stroke="rgba(255,255,255,.10)" stroke-width="2"/>

            <!-- red accents -->
            <path d="M60 118c18-30 50-54 90-54s72 24 90 54" fill="none" stroke="rgba(255,0,0,.18)" stroke-width="10" />
          </svg>

          <div class="screamer__text">DON'T BLINK</div>
        </div>
      </div>
    </div>

    <div class="hint">
      
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      // ===== Canvas setup =====
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      const stageEl = document.getElementById('stage');

      const WORLD_W = 288;
      const WORLD_H = 512;

      function setupDPR(){
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const cssW = canvas.clientWidth;
        const cssH = (cssW / WORLD_W) * WORLD_H;
        canvas.style.height = cssH + 'px';
        canvas.width = Math.round(WORLD_W * dpr);
        canvas.height = Math.round(WORLD_H * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      requestAnimationFrame(setupDPR);
      window.addEventListener('resize', () => requestAnimationFrame(setupDPR));

      // ===== Game constants =====
      const GRAVITY = 900;
      const FLAP_VY = -285;
      const MAX_FALL = 420;

      const PIPE_W = 56;
      const GROUND_H = 88;

      const BIRD_R = 12;
      const BIRD_X = 88;

      const BASE = { pipeSpeed: 140, pipeInterval: 1.25, gap: 142 };

      // ===== State =====
      const State = { READY:'ready', PLAY:'play', OVER:'over', PAUSE:'pause' };
      let state = State.READY;
      let lastT = 0;
      let accSpawn = 0;

      // Auto player
      let autoMode = true;
      let aiCooldown = 0;
      let readyAutoTimer = 0;
      let overAutoTimer = 0;

      // Screamer
      const screamerEl = document.getElementById('screamer');
      let screamerEnabled = true;
      let screamerCooldown = 0;

      // Optional sound via WebAudio (needs user gesture to unlock)
      let audioCtx = null;
      let audioUnlocked = false;

      const bird = { x:BIRD_X, y:WORLD_H*0.42, vy:0, rot:0, bobT:0 };

      /** @type {{x:number, gapY:number, gap:number, passed:boolean}[]} */
      let pipes = [];
      let score = 0;
      let best = Number(localStorage.getItem('flappy_best_auto_screamer') || '0') || 0;

      const btnAuto = document.getElementById('btnAuto');
      const btnScreamer = document.getElementById('btnScreamer');
      const btnPause = document.getElementById('btnPause');
      const btnReset = document.getElementById('btnReset');

      // ===== Utilities =====
      const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

      function levelFromScore(s){ return 1 + Math.floor(s / 10); }

      function paramsForLevel(level){
        const pipeSpeed = Math.min(240, BASE.pipeSpeed + (level-1)*10);
        const gap = Math.max(100, BASE.gap - (level-1)*4);
        const pipeInterval = Math.max(0.85, BASE.pipeInterval - (level-1)*0.04);
        return { level, pipeSpeed, gap, pipeInterval };
      }

      function setBest(v){
        best = Math.max(best, v);
        localStorage.setItem('flappy_best_auto_screamer', String(best));
      }

      function reset(toReady = true){
        pipes = [];
        score = 0;
        accSpawn = 0;
        bird.x = BIRD_X;
        bird.y = WORLD_H * 0.42;
        bird.vy = 0;
        bird.rot = 0;
        bird.bobT = 0;
        aiCooldown = 0;
        readyAutoTimer = 0;
        overAutoTimer = 0;
        screamerCooldown = 0;
        hideScreamer(true);
        state = toReady ? State.READY : State.PLAY;
      }

      function randGapY(gap){
        const topMargin = 46;
        const bottomMargin = GROUND_H + 46;
        const minY = topMargin + gap/2;
        const maxY = WORLD_H - bottomMargin - gap/2;
        return minY + Math.random() * (maxY - minY);
      }

      function spawnPipe(currentGap){
        pipes.push({ x: WORLD_W + 10, gapY: randGapY(currentGap), gap: currentGap, passed: false });
      }

      function flap(){
        if (state === State.READY){
          state = State.PLAY;
          bird.vy = FLAP_VY;
          accSpawn = BASE.pipeInterval;
          return;
        }
        if (state === State.PLAY){
          bird.vy = FLAP_VY;
        }
        if (state === State.OVER){
          reset(true);
        }
      }

      function togglePause(){
        if (state === State.PLAY){
          state = State.PAUSE;
          btnPause.textContent = 'Продолжить';
          return;
        }
        if (state === State.PAUSE){
          state = State.PLAY;
          btnPause.textContent = 'Пауза';
          lastT = performance.now();
        }
      }

      function unlockAudio(){
        if (audioUnlocked) return;
        audioUnlocked = true;
        try{
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }catch(_e){
          audioCtx = null;
        }
      }

      function playScreamSound(){
        if (!audioCtx || audioCtx.state === 'closed') return;
        // Some browsers start suspended
        if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});

        const t0 = audioCtx.currentTime;

        // Main harsh oscillator
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sawtooth';

        // Quick pitch sweep
        o.frequency.setValueAtTime(260, t0);
        o.frequency.exponentialRampToValueAtTime(980, t0 + 0.16);
        o.frequency.exponentialRampToValueAtTime(420, t0 + 0.34);

        // Volume envelope (not too loud)
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.35, t0 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.38);

        // Bit of tremolo
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();
        lfo.type = 'square';
        lfo.frequency.setValueAtTime(28, t0);
        lfoGain.gain.setValueAtTime(0.10, t0);
        lfo.connect(lfoGain);
        lfoGain.connect(g.gain);

        // Slight lowpass to reduce ear-piercing highs
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(2600, t0);
        filter.Q.setValueAtTime(0.8, t0);

        o.connect(filter);
        filter.connect(g);
        g.connect(audioCtx.destination);

        o.start(t0);
        lfo.start(t0);
        o.stop(t0 + 0.40);
        lfo.stop(t0 + 0.40);
      }

      function showScreamer(){
        if (!screamerEnabled) return;
        if (screamerCooldown > 0) return;

        // Restart animation reliably
        screamerEl.classList.remove('on');
        // force reflow
        void screamerEl.offsetWidth;
        screamerEl.classList.add('on');

        // Hide after short time
        setTimeout(() => hideScreamer(false), 650);

        // Cooldown so auto-mode doesn't spam it every death loop
        screamerCooldown = 1.6;

        // Play sound if unlocked
        playScreamSound();
      }

      function hideScreamer(immediate){
        if (immediate){
          screamerEl.classList.remove('on');
          screamerEl.style.display = '';
          return;
        }
        // Keep display controlled by class; removing class hides it.
        screamerEl.classList.remove('on');
      }

      function die(){
        state = State.OVER;
        setBest(score);
        overAutoTimer = 0;
        showScreamer();
      }

      // ===== Collision =====
      function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
        const nx = clamp(cx, rx, rx + rw);
        const ny = clamp(cy, ry, ry + rh);
        const dx = cx - nx;
        const dy = cy - ny;
        return (dx*dx + dy*dy) <= r*r;
      }

      function checkCollisions(){
        if (bird.y + BIRD_R >= WORLD_H - GROUND_H) return true;
        if (bird.y - BIRD_R <= 0) return true;

        for (const p of pipes){
          const gapTop = p.gapY - p.gap/2;
          const gapBot = p.gapY + p.gap/2;
          if (circleRectCollide(bird.x, bird.y, BIRD_R, p.x, 0, PIPE_W, gapTop)) return true;
          if (circleRectCollide(bird.x, bird.y, BIRD_R, p.x, gapBot, PIPE_W, (WORLD_H - GROUND_H) - gapBot)) return true;
        }
        return false;
      }

      // ===== Auto player =====
      function nextPipeAhead(){
        let bestPipe = null;
        let bestDx = Infinity;
        for (const p of pipes){
          const dx = (p.x + PIPE_W) - (bird.x - BIRD_R);
          if (dx >= 0 && dx < bestDx){
            bestDx = dx;
            bestPipe = p;
          }
        }
        return bestPipe;
      }

      function aiControl(dt, pipeSpeed){
        aiCooldown = Math.max(0, aiCooldown - dt);
        if (aiCooldown > 0) return;

        const groundY = WORLD_H - GROUND_H - BIRD_R;
        if (bird.y > groundY - 34){
          bird.vy = FLAP_VY;
          aiCooldown = 0.12;
          return;
        }

        const p = nextPipeAhead();
        if (!p){
          const target = WORLD_H * 0.42;
          if (bird.y > target + 10 && bird.vy > -60){
            bird.vy = FLAP_VY;
            aiCooldown = 0.12;
          }
          return;
        }

        const aimOffset = clamp(-8 - (pipeSpeed - BASE.pipeSpeed) * 0.05, -18, -6);
        const targetY = p.gapY + aimOffset;

        const pipeCenterX = p.x + PIPE_W * 0.55;
        const dx = pipeCenterX - bird.x;
        const tToPipe = clamp(dx / Math.max(1, pipeSpeed), 0, 0.75);
        const yPred = bird.y + bird.vy * tToPipe + 0.5 * GRAVITY * tToPipe * tToPipe;

        const tol = clamp(p.gap * 0.12, 10, 18);
        if (bird.y < 36) return;

        if (yPred > targetY + tol){
          bird.vy = FLAP_VY;
          aiCooldown = 0.12;
          return;
        }
        if (bird.vy > 210 && bird.y > targetY){
          bird.vy = FLAP_VY;
          aiCooldown = 0.12;
        }
      }

      // ===== Update =====
      function update(dt){
        if (state === State.PAUSE) return;

        screamerCooldown = Math.max(0, screamerCooldown - dt);

        const lvl = levelFromScore(score);
        const P = paramsForLevel(lvl);

        if (state === State.READY){
          bird.bobT += dt;
          bird.y = WORLD_H * 0.42 + Math.sin(bird.bobT * 3.2) * 6;
          bird.rot = Math.sin(bird.bobT * 2.8) * 0.08;

          if (autoMode){
            readyAutoTimer += dt;
            if (readyAutoTimer > 0.45) flap();
          }
          return;
        }

        if (autoMode && state === State.PLAY){
          aiControl(dt, P.pipeSpeed);
        }

        bird.vy = clamp(bird.vy + GRAVITY * dt, -1000, MAX_FALL);
        bird.y += bird.vy * dt;
        bird.rot = clamp(bird.vy / 600, -0.55, 1.15);

        if (state === State.PLAY){
          accSpawn += dt;
          if (accSpawn >= P.pipeInterval){
            accSpawn -= P.pipeInterval;
            spawnPipe(P.gap);
          }

          for (const p of pipes) p.x -= P.pipeSpeed * dt;
          while (pipes.length && pipes[0].x + PIPE_W < -10) pipes.shift();

          for (const p of pipes){
            if (!p.passed && p.x + PIPE_W < bird.x - BIRD_R){
              p.passed = true;
              score += 1;
            }
          }

          if (checkCollisions()) die();
        }

        if (state === State.OVER){
          if (bird.y + BIRD_R > WORLD_H - GROUND_H){
            bird.y = WORLD_H - GROUND_H - BIRD_R;
            bird.vy = 0;
            bird.rot = 1.05;
          }

          if (autoMode){
            overAutoTimer += dt;
            if (overAutoTimer > 0.9){
              reset(true);
            }
          }
        }
      }

      // ===== Render =====
      function drawCloud(x,y,r){
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x,y,r*0.55,0,Math.PI*2);
        ctx.arc(x+r*0.45,y+r*0.08,r*0.45,0,Math.PI*2);
        ctx.arc(x+r*0.85,y,r*0.40,0,Math.PI*2);
        ctx.closePath();
        ctx.fill();
      }

      function drawBackground(t){
        const g = ctx.createLinearGradient(0,0,0,WORLD_H);
        g.addColorStop(0,'#73d0db');
        g.addColorStop(1,'#d4f2f6');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,WORLD_W,WORLD_H);

        const cloudX = (t*18) % (WORLD_W + 140);
        ctx.globalAlpha = 0.35;
        drawCloud(WORLD_W - cloudX, 72, 54);
        drawCloud(WORLD_W - cloudX + 180, 108, 44);
        drawCloud(WORLD_W - cloudX + 340, 82, 38);
        ctx.globalAlpha = 1;

        ctx.fillStyle = 'rgba(34,139,34,0.22)';
        ctx.beginPath();
        ctx.moveTo(0, WORLD_H - GROUND_H - 30);
        ctx.quadraticCurveTo(WORLD_W*0.25, WORLD_H - GROUND_H - 70, WORLD_W*0.5, WORLD_H - GROUND_H - 28);
        ctx.quadraticCurveTo(WORLD_W*0.75, WORLD_H - GROUND_H + 20, WORLD_W, WORLD_H - GROUND_H - 34);
        ctx.lineTo(WORLD_W, WORLD_H - GROUND_H);
        ctx.lineTo(0, WORLD_H - GROUND_H);
        ctx.closePath();
        ctx.fill();
      }

      function drawPipes(){
        for (const p of pipes){
          const gapTop = p.gapY - p.gap/2;
          const gapBot = p.gapY + p.gap/2;

          const grd = ctx.createLinearGradient(p.x,0,p.x+PIPE_W,0);
          grd.addColorStop(0,'#2ecc71');
          grd.addColorStop(0.5,'#27ae60');
          grd.addColorStop(1,'#1f8f4d');
          ctx.fillStyle = grd;

          ctx.fillRect(p.x,0,PIPE_W,gapTop);
          ctx.fillRect(p.x,gapBot,PIPE_W,(WORLD_H-GROUND_H)-gapBot);

          ctx.fillStyle = 'rgba(0,0,0,.18)';
          ctx.fillRect(p.x-4, gapTop-12, PIPE_W+8, 12);
          ctx.fillRect(p.x-4, gapBot, PIPE_W+8, 12);

          ctx.fillStyle = 'rgba(255,255,255,.22)';
          ctx.fillRect(p.x+8,0,6,gapTop);
          ctx.fillRect(p.x+8,gapBot,6,(WORLD_H-GROUND_H)-gapBot);
        }
      }

      function drawGround(t){
        ctx.fillStyle = '#deaa55';
        ctx.fillRect(0, WORLD_H - GROUND_H, WORLD_W, GROUND_H);
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(0, WORLD_H - GROUND_H, WORLD_W, 18);

        const offset = Math.floor((t*90) % 24);
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#8a5a2b';
        for (let x=-24+offset; x < WORLD_W+24; x+=24){
          ctx.fillRect(x, WORLD_H - GROUND_H + 26, 12, 10);
          ctx.fillRect(x+10, WORLD_H - GROUND_H + 52, 10, 8);
        }
        ctx.globalAlpha = 1;
      }

      function drawBird(){
        ctx.save();
        ctx.translate(bird.x, bird.y);
        ctx.rotate(bird.rot);

        ctx.fillStyle = '#ffd54a';
        ctx.beginPath();
        ctx.arc(0,0,BIRD_R,0,Math.PI*2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255,255,255,.65)';
        ctx.beginPath();
        ctx.arc(2,4,BIRD_R*0.55,0,Math.PI*2);
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(4,-4,4.5,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(5.5,-4,2.1,0,Math.PI*2);
        ctx.fill();

        ctx.fillStyle = '#ff8a3d';
        ctx.beginPath();
        ctx.moveTo(BIRD_R-2,1);
        ctx.lineTo(BIRD_R+10,4);
        ctx.lineTo(BIRD_R-2,7);
        ctx.closePath();
        ctx.fill();

        const flapAnim = Math.sin((performance.now()/1000)*16) * 0.25;
        ctx.fillStyle = 'rgba(0,0,0,.10)';
        ctx.beginPath();
        ctx.ellipse(-4,2,7.5,5,-0.6+flapAnim,0,Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(0,0,0,.22)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0,0,BIRD_R,0,Math.PI*2);
        ctx.stroke();

        ctx.restore();
      }

      function roundRect(x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y, x+w,y+h, rr);
        ctx.arcTo(x+w,y+h, x,y+h, rr);
        ctx.arcTo(x,y+h, x,y, rr);
        ctx.arcTo(x,y, x+w,y, rr);
        ctx.closePath();
      }

      function drawPanel(title, subtitle, footer){
        const w = 232;
        const h = footer ? 116 : 98;
        const x = (WORLD_W - w)/2;
        const y = WORLD_H * 0.26;

        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,.75)';
        ctx.strokeStyle = 'rgba(0,0,0,.15)';
        ctx.lineWidth = 1;
        roundRect(x,y,w,h,14);
        ctx.fill();
        ctx.stroke();

        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        ctx.fillStyle = 'rgba(0,0,0,.86)';
        ctx.font = '800 18px system-ui, sans-serif';
        ctx.fillText(title, WORLD_W/2, y+14);

        ctx.fillStyle = 'rgba(0,0,0,.65)';
        ctx.font = '650 13px system-ui, sans-serif';
        ctx.fillText(subtitle, WORLD_W/2, y+44);

        if (footer){
          ctx.fillStyle = 'rgba(0,0,0,.58)';
          ctx.font = '600 12px system-ui, sans-serif';
          ctx.fillText(footer, WORLD_W/2, y+74);
        }
        ctx.restore();
      }

      function drawHUD(){
        const lvl = levelFromScore(score);
        const P = paramsForLevel(lvl);

        ctx.save();
        ctx.font = 'bold 28px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const text = String(score);
        ctx.lineWidth = 5;
        ctx.strokeStyle = 'rgba(0,0,0,.35)';
        ctx.fillStyle = '#fff';
        ctx.strokeText(text, WORLD_W/2, 18);
        ctx.fillText(text, WORLD_W/2, 18);
        ctx.restore();

        ctx.save();
        ctx.font = '600 12px system-ui, sans-serif';
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        ctx.textAlign = 'left';
        ctx.fillText('lvl: ' + P.level, 10, 10);
        ctx.textAlign = 'right';
        ctx.fillText('best: ' + best, WORLD_W - 10, 10);
        ctx.restore();

        if (state === State.READY){
          drawPanel('Авто-режим готов', autoMode ? 'Старт через мгновение…' : 'Нажми пробел/тап для старта', 'S — скример, A — авто');
        } else if (state === State.OVER){
          drawPanel('Game Over', `Счёт: ${score}  •  Лучший: ${best}`, autoMode ? 'Авто-рестарт…' : 'Пробел/тап — рестарт');
        } else if (state === State.PAUSE){
          drawPanel('Пауза', 'Нажми «Продолжить» или P');
        }
      }

      function render(t){
        drawBackground(t);
        drawPipes();
        drawBird();
        drawGround(t);
        drawHUD();
      }

      // ===== Main loop =====
      function loop(now){
        const t = now / 1000;
        const dt = lastT ? Math.min(0.033, (now - lastT)/1000) : 0;
        lastT = now;
        if (dt > 0) update(dt);
        render(t);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // ===== Input =====
      function onPress(e){
        if (e){
          if (e.type === 'touchstart' || e.type === 'pointerdown') e.preventDefault();
        }
        unlockAudio();
        flap();
      }
      stageEl.addEventListener('pointerdown', onPress, { passive:false });

      window.addEventListener('keydown', (e) => {
        unlockAudio();

        if (e.code === 'Space' || e.code === 'ArrowUp'){
          e.preventDefault();
          flap();
        }
        if (e.code === 'KeyP'){
          e.preventDefault();
          togglePause();
        }
        if (e.code === 'KeyR'){
          e.preventDefault();
          btnPause.textContent = 'Пауза';
          reset(true);
        }
        if (e.code === 'KeyA'){
          e.preventDefault();
          autoMode = !autoMode;
          btnAuto.textContent = autoMode ? 'Авто: ВКЛ' : 'Авто: ВЫКЛ';
          if (autoMode){ readyAutoTimer = 0; overAutoTimer = 0; }
        }
        if (e.code === 'KeyS'){
          e.preventDefault();
          screamerEnabled = !screamerEnabled;
          btnScreamer.textContent = screamerEnabled ? 'Скример: ВКЛ' : 'Скример: ВЫКЛ';
          if (!screamerEnabled) hideScreamer(true);
        }
      }, { passive:false });

      btnAuto.addEventListener('click', () => {
        unlockAudio();
        autoMode = !autoMode;
        btnAuto.textContent = autoMode ? 'Авто: ВКЛ' : 'Авто: ВЫКЛ';
        if (autoMode){ readyAutoTimer = 0; overAutoTimer = 0; }
      });

      btnScreamer.addEventListener('click', () => {
        unlockAudio();
        screamerEnabled = !screamerEnabled;
        btnScreamer.textContent = screamerEnabled ? 'Скример: ВКЛ' : 'Скример: ВЫКЛ';
        if (!screamerEnabled) hideScreamer(true);
      });

      btnPause.addEventListener('click', () => togglePause());

      btnReset.addEventListener('click', () => {
        btnPause.textContent = 'Пауза';
        reset(true);
      });

      reset(true);
    })();
  </script>
  <script>
    document.querySelector('#btnAuto').click();
  </script>
  <style>
    #btnAuto, #btnScreamer{
        display: none;
    }
  </style>
</body>

</html>
